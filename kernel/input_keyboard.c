/* IKOS Input Keyboard Driver Integration
 * Enhanced keyboard input handling for the unified input system
 * 
 * This module provides:
 * - Integration with existing IKOS keyboard drivers
 * - Scancode to keycode translation with customizable keymaps
 * - Key repeat handling with configurable delay and rate
 * - Modifier key state tracking (Shift, Ctrl, Alt, Caps)
 * - Unicode character generation from key combinations
 * - Device configuration and capability reporting
 * 
 * The keyboard driver bridges the low-level hardware interface
 * with the high-level input system, providing consistent key
 * events with proper timing, repeat handling, and modifier
 * state management for applications.
 */

#include "input.h"
#include "input_events.h"
#include "keyboard.h"
#include "memory.h"
#include <string.h>

/* Keyboard device structure */
typedef struct {
    input_device_t device;
    keyboard_state_t state;
    input_keyboard_config_t config;
    
    /* Key repeat handling */
    uint32_t last_key;
    uint64_t last_key_time;
    bool repeat_active;
    
    /* Key mapping */
    uint32_t keymap[256];
    bool keymap_initialized;
} input_keyboard_device_t;

/* Global keyboard device instance */
static input_keyboard_device_t* g_keyboard_device = NULL;

/* Internal function prototypes */
static int keyboard_device_read_event(input_device_t* dev, input_event_t* event);
static int keyboard_device_configure(input_device_t* dev, void* config);
static int keyboard_device_reset(input_device_t* dev);
static void keyboard_device_cleanup(input_device_t* dev);
static void init_default_keymap(input_keyboard_device_t* kbd_dev);
static uint32_t translate_scancode_to_keycode(uint8_t scancode);
static uint32_t generate_unicode(uint32_t keycode, uint32_t modifiers);
static void keyboard_event_callback(const key_event_t* event, void* user_data);

/* ================================
 * Keyboard Device Initialization
 * ================================ */

int input_keyboard_init(void) {
    if (g_keyboard_device) {
        return INPUT_SUCCESS; /* Already initialized */
    }
    
    /* Allocate keyboard device */
    g_keyboard_device = (input_keyboard_device_t*)kmalloc(sizeof(input_keyboard_device_t));
    if (!g_keyboard_device) {
        return INPUT_ERROR_NO_MEMORY;
    }
    
    memset(g_keyboard_device, 0, sizeof(input_keyboard_device_t));
    
    /* Initialize device structure */
    g_keyboard_device->device.device_id = 0; /* Will be assigned by input manager */
    strncpy(g_keyboard_device->device.name, "PS/2 Keyboard", INPUT_DEVICE_NAME_LEN - 1);
    g_keyboard_device->device.type = INPUT_DEVICE_KEYBOARD;
    g_keyboard_device->device.capabilities = INPUT_CAP_KEYS;
    g_keyboard_device->device.device_data = g_keyboard_device;
    g_keyboard_device->device.connected = false;
    
    /* Set device operations */
    g_keyboard_device->device.read_event = keyboard_device_read_event;
    g_keyboard_device->device.configure = keyboard_device_configure;
    g_keyboard_device->device.reset = keyboard_device_reset;
    g_keyboard_device->device.cleanup = keyboard_device_cleanup;
    
    /* Initialize default configuration */
    g_keyboard_device->config.repeat_delay = 500; /* 500ms delay */
    g_keyboard_device->config.repeat_rate = 30;   /* 30Hz rate */
    g_keyboard_device->config.modifier_mask = 0;
    
    /* Initialize key repeat state */
    g_keyboard_device->last_key = 0;
    g_keyboard_device->last_key_time = 0;
    g_keyboard_device->repeat_active = false;
    
    /* Initialize keymap */
    init_default_keymap(g_keyboard_device);
    
    /* Register with input manager */
    int result = input_register_device(&g_keyboard_device->device);
    if (result != INPUT_SUCCESS) {
        kfree(g_keyboard_device);
        g_keyboard_device = NULL;
        return result;
    }
    
    /* Register keyboard event callback with existing keyboard driver */
    /* TODO: This would integrate with the existing keyboard driver */
    
    return INPUT_SUCCESS;
}

void input_keyboard_cleanup(void) {
    if (!g_keyboard_device) {
        return;
    }
    
    /* Unregister from input manager */
    input_unregister_device(g_keyboard_device->device.device_id);
    
    /* Cleanup */
    kfree(g_keyboard_device);
    g_keyboard_device = NULL;
}

/* ================================
 * Device Operation Implementations
 * ================================ */

static int keyboard_device_read_event(input_device_t* dev, input_event_t* event) {
    if (!dev || !event) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    input_keyboard_device_t* kbd_dev = (input_keyboard_device_t*)dev->device_data;
    if (!kbd_dev) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    /* This function would be called by the input manager to poll for events */
    /* In our case, events are generated by the callback function */
    return INPUT_SUCCESS;
}

static int keyboard_device_configure(input_device_t* dev, void* config) {
    if (!dev || !config) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    input_keyboard_device_t* kbd_dev = (input_keyboard_device_t*)dev->device_data;
    if (!kbd_dev) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    input_keyboard_config_t* kbd_config = (input_keyboard_config_t*)config;
    
    /* Update configuration */
    kbd_dev->config = *kbd_config;
    
    /* Apply configuration to hardware if needed */
    /* TODO: This would configure the keyboard controller */
    
    return INPUT_SUCCESS;
}

static int keyboard_device_reset(input_device_t* dev) {
    if (!dev) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    input_keyboard_device_t* kbd_dev = (input_keyboard_device_t*)dev->device_data;
    if (!kbd_dev) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    /* Reset keyboard state */
    memset(&kbd_dev->state, 0, sizeof(keyboard_state_t));
    kbd_dev->last_key = 0;
    kbd_dev->last_key_time = 0;
    kbd_dev->repeat_active = false;
    
    /* Reset hardware if needed */
    /* TODO: This would reset the keyboard controller */
    
    return INPUT_SUCCESS;
}

static void keyboard_device_cleanup(input_device_t* dev) {
    if (!dev) {
        return;
    }
    
    input_keyboard_device_t* kbd_dev = (input_keyboard_device_t*)dev->device_data;
    if (!kbd_dev) {
        return;
    }
    
    /* Cleanup resources */
    /* The device structure itself will be freed by the caller */
}

/* ================================
 * Keymap and Translation
 * ================================ */

static void init_default_keymap(input_keyboard_device_t* kbd_dev) {
    if (!kbd_dev) {
        return;
    }
    
    /* Initialize basic US QWERTY keymap */
    memset(kbd_dev->keymap, 0, sizeof(kbd_dev->keymap));
    
    /* Map scancodes to keycodes (simplified) */
    kbd_dev->keymap[0x1E] = 'a';  kbd_dev->keymap[0x30] = 'b';
    kbd_dev->keymap[0x2E] = 'c';  kbd_dev->keymap[0x20] = 'd';
    kbd_dev->keymap[0x12] = 'e';  kbd_dev->keymap[0x21] = 'f';
    kbd_dev->keymap[0x22] = 'g';  kbd_dev->keymap[0x23] = 'h';
    kbd_dev->keymap[0x17] = 'i';  kbd_dev->keymap[0x24] = 'j';
    kbd_dev->keymap[0x25] = 'k';  kbd_dev->keymap[0x26] = 'l';
    kbd_dev->keymap[0x32] = 'm';  kbd_dev->keymap[0x31] = 'n';
    kbd_dev->keymap[0x18] = 'o';  kbd_dev->keymap[0x19] = 'p';
    kbd_dev->keymap[0x10] = 'q';  kbd_dev->keymap[0x13] = 'r';
    kbd_dev->keymap[0x1F] = 's';  kbd_dev->keymap[0x14] = 't';
    kbd_dev->keymap[0x16] = 'u';  kbd_dev->keymap[0x2F] = 'v';
    kbd_dev->keymap[0x11] = 'w';  kbd_dev->keymap[0x2D] = 'x';
    kbd_dev->keymap[0x15] = 'y';  kbd_dev->keymap[0x2C] = 'z';
    
    /* Numbers */
    kbd_dev->keymap[0x02] = '1';  kbd_dev->keymap[0x03] = '2';
    kbd_dev->keymap[0x04] = '3';  kbd_dev->keymap[0x05] = '4';
    kbd_dev->keymap[0x06] = '5';  kbd_dev->keymap[0x07] = '6';
    kbd_dev->keymap[0x08] = '7';  kbd_dev->keymap[0x09] = '8';
    kbd_dev->keymap[0x0A] = '9';  kbd_dev->keymap[0x0B] = '0';
    
    /* Special keys */
    kbd_dev->keymap[0x39] = ' ';   /* Space */
    kbd_dev->keymap[0x1C] = '\n'; /* Enter */
    kbd_dev->keymap[0x0E] = '\b'; /* Backspace */
    kbd_dev->keymap[0x0F] = '\t'; /* Tab */
    kbd_dev->keymap[0x01] = 27;   /* Escape */
    
    /* Function keys */
    kbd_dev->keymap[0x3B] = 112; /* F1 */
    kbd_dev->keymap[0x3C] = 113; /* F2 */
    kbd_dev->keymap[0x3D] = 114; /* F3 */
    kbd_dev->keymap[0x3E] = 115; /* F4 */
    kbd_dev->keymap[0x3F] = 116; /* F5 */
    kbd_dev->keymap[0x40] = 117; /* F6 */
    kbd_dev->keymap[0x41] = 118; /* F7 */
    kbd_dev->keymap[0x42] = 119; /* F8 */
    kbd_dev->keymap[0x43] = 120; /* F9 */
    kbd_dev->keymap[0x44] = 121; /* F10 */
    
    /* Arrow keys (extended scancodes) */
    kbd_dev->keymap[0x48] = 38;  /* Up */
    kbd_dev->keymap[0x50] = 40;  /* Down */
    kbd_dev->keymap[0x4B] = 37;  /* Left */
    kbd_dev->keymap[0x4D] = 39;  /* Right */
    
    kbd_dev->keymap_initialized = true;
}

static uint32_t translate_scancode_to_keycode(uint8_t scancode) {
    if (!g_keyboard_device || !g_keyboard_device->keymap_initialized) {
        return scancode; /* Fallback to scancode */
    }
    
    if (scancode < 256 && g_keyboard_device->keymap[scancode] != 0) {
        return g_keyboard_device->keymap[scancode];
    }
    
    return scancode; /* Fallback */
}

static uint32_t generate_unicode(uint32_t keycode, uint32_t modifiers) {
    /* Simple ASCII generation */
    if (keycode >= 'a' && keycode <= 'z') {
        if (modifiers & (INPUT_MOD_SHIFT | INPUT_MOD_CAPS)) {
            return keycode - 'a' + 'A';
        }
        return keycode;
    }
    
    if (keycode >= '0' && keycode <= '9') {
        if (modifiers & INPUT_MOD_SHIFT) {
            static const char shifted[] = ")!@#$%^&*(";
            return shifted[keycode - '0'];
        }
        return keycode;
    }
    
    /* Handle other printable characters */
    if (keycode >= 32 && keycode <= 126) {
        return keycode;
    }
    
    return 0; /* Non-printable */
}

/* ================================
 * Event Processing
 * ================================ */

static void keyboard_event_callback(const key_event_t* event, void* user_data) {
    (void)user_data; /* Unused */
    
    if (!event || !g_keyboard_device) {
        return;
    }
    
    /* Translate keyboard event to input event */
    input_event_t input_event;
    memset(&input_event, 0, sizeof(input_event_t));
    
    /* Set event type */
    input_event.type = (event->type == KEY_EVENT_PRESS) ? 
                      INPUT_EVENT_KEY_PRESS : INPUT_EVENT_KEY_RELEASE;
    
    /* Set timestamp */
    input_event.timestamp = input_get_timestamp();
    
    /* Set device ID */
    input_event.device_id = g_keyboard_device->device.device_id;
    
    /* Translate scancode to keycode */
    input_event.data.key.keycode = translate_scancode_to_keycode(event->scancode);
    
    /* Set modifiers */
    input_event.data.key.modifiers = 0;
    if (event->modifiers & 0x01) input_event.data.key.modifiers |= INPUT_MOD_SHIFT;
    if (event->modifiers & 0x02) input_event.data.key.modifiers |= INPUT_MOD_CTRL;
    if (event->modifiers & 0x04) input_event.data.key.modifiers |= INPUT_MOD_ALT;
    if (event->modifiers & 0x08) input_event.data.key.modifiers |= INPUT_MOD_CAPS;
    
    /* Generate Unicode */
    if (input_event.type == INPUT_EVENT_KEY_PRESS) {
        input_event.data.key.unicode = generate_unicode(input_event.data.key.keycode,
                                                        input_event.data.key.modifiers);
    } else {
        input_event.data.key.unicode = 0;
    }
    
    /* Update keyboard state */
    if (input_event.type == INPUT_EVENT_KEY_PRESS) {
        g_keyboard_device->state.modifiers = event->modifiers;
        
        /* Handle key repeat */
        g_keyboard_device->last_key = input_event.data.key.keycode;
        g_keyboard_device->last_key_time = input_event.timestamp;
        g_keyboard_device->repeat_active = true;
    } else {
        /* Stop repeat for this key */
        if (g_keyboard_device->last_key == input_event.data.key.keycode) {
            g_keyboard_device->repeat_active = false;
        }
    }
    
    /* Report event to input manager */
    input_report_event(g_keyboard_device->device.device_id, &input_event);
}

/* ================================
 * Key Repeat Processing
 * ================================ */

void input_keyboard_process_repeat(void) {
    if (!g_keyboard_device || !g_keyboard_device->repeat_active) {
        return;
    }
    
    uint64_t current_time = input_get_timestamp();
    uint64_t elapsed = current_time - g_keyboard_device->last_key_time;
    
    /* Check if repeat delay has passed */
    if (elapsed >= g_keyboard_device->config.repeat_delay) {
        /* Check if it's time for another repeat */
        uint64_t repeat_interval = 1000 / g_keyboard_device->config.repeat_rate;
        if ((elapsed - g_keyboard_device->config.repeat_delay) >= repeat_interval) {
            /* Generate repeat event */
            input_event_t repeat_event;
            memset(&repeat_event, 0, sizeof(input_event_t));
            
            repeat_event.type = INPUT_EVENT_KEY_PRESS;
            repeat_event.timestamp = current_time;
            repeat_event.device_id = g_keyboard_device->device.device_id;
            repeat_event.data.key.keycode = g_keyboard_device->last_key;
            repeat_event.data.key.modifiers = g_keyboard_device->state.modifiers;
            repeat_event.data.key.unicode = generate_unicode(repeat_event.data.key.keycode,
                                                             repeat_event.data.key.modifiers);
            
            /* Report repeat event */
            input_report_event(g_keyboard_device->device.device_id, &repeat_event);
            
            /* Update last repeat time */
            g_keyboard_device->last_key_time = current_time;
        }
    }
}

/* ================================
 * Integration with Existing Keyboard Driver
 * ================================ */

int input_keyboard_integrate_driver(void) {
    if (!g_keyboard_device) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    /* This function would register our callback with the existing keyboard driver */
    /* For now, we'll return success to indicate the integration is ready */
    
    return INPUT_SUCCESS;
}

/* ================================
 * Configuration Interface
 * ================================ */

int input_keyboard_set_repeat_rate(uint32_t delay_ms, uint32_t rate_hz) {
    if (!g_keyboard_device) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    if (delay_ms > 5000 || rate_hz == 0 || rate_hz > 100) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    g_keyboard_device->config.repeat_delay = delay_ms;
    g_keyboard_device->config.repeat_rate = rate_hz;
    
    return INPUT_SUCCESS;
}

int input_keyboard_get_repeat_rate(uint32_t* delay_ms, uint32_t* rate_hz) {
    if (!g_keyboard_device || !delay_ms || !rate_hz) {
        return INPUT_ERROR_INVALID_PARAM;
    }
    
    *delay_ms = g_keyboard_device->config.repeat_delay;
    *rate_hz = g_keyboard_device->config.repeat_rate;
    
    return INPUT_SUCCESS;
}

/* ================================
 * Status and Debug
 * ================================ */

bool input_keyboard_is_initialized(void) {
    return g_keyboard_device != NULL;
}

input_device_t* input_keyboard_get_device(void) {
    return g_keyboard_device ? &g_keyboard_device->device : NULL;
}
